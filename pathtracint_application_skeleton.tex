

\section{Application to path tracing}

\subsection{The path tracing algorithm}

Path tracing is a global illumination algorithm that is able to render photo-realistic images of a scene viewed by a camera. The idea behind the algorithm is very simple: for each pixel of the image, throw rays of light through the pixel that will bounce on the scene to accumulate lighting exchanges. It is based on physical laws of radiometry.

\subsubsection{Basic definitions of radiometry}

Let $S$ be a set of surfaces of $\Rset^3$ that don't overlap ($\forall x \in \Rset^3$ there exists at most one surface of $S$ that contains $x$) and $S_L \subset S$ a set of surface lights. $S$ is called the scene.

The basic radiometric quantity is the \myem{radiance} $L(x \rightarrow \Theta)$ that express the quantity of light energy produce by the surface point $x \in \Rset^3$ towards direction $\Theta \in \Omega_x$ per unit of time per unit area per unit solid angle (expressed in $W.m^{-2}.sr^{-1}$).
This is the quantity that the eye actually "sees" and that must be computed. 

% image radiance

We can define another quantity related to radiance called \myem{incoming radiance} $L(x \leftarrow \Phi)$ that represents the radiance that reach $x$ from direction $\Phi$.

\begin{property}

The radiance remains constant along straight lines in the void.

\end{property}

That property allows us to write the incoming radiance in terms of radiance.

\begin{equation*}
L(x \leftarrow \Phi) = L(r(x, \Phi) \rightarrow -\Phi)
\end{equation*}

$r(x, \Phi)$ is the surface point seen by $x$ in the direction $\Phi$. It can be defined formally by:

\begin{align*}
r(x, \Phi) &= x + t_{min}\Phi \\
t_{min} &= min \lbrace t \in (0, +\infty]~ |~ x + t\Phi \in S \rbrace
\end{align*}

If $t_{min} = \infty$ then $r(x, \Phi)$ is undefined and $L(x \leftarrow \Phi) = 0$. We call $r$ the \myem{raytrace} function. In practice it is implemented by throwing a ray in the scene and looking for the first intersection.

A third quantity related to radiance is \myem{emitted radiance} $L_e(x \rightarrow \Theta)$. It is not null if $x$ is a point of a light source ($x \in S_L$). In practice the emitted radiance is given with the set $S_L$ as an input of the algorithm (in can be constant across each of the lights or given by a texture).

The radiance is the solution of an equation called the Rendering Equation:

\begin{align*}
L(x \rightarrow \Theta) &= L_e(x \rightarrow \Theta) + \int_{\Phi \in \Omega_x} f_r(x, \Theta \leftrightarrow \Phi) L(x \leftarrow \Phi) cos(N_x, \Phi) d\omega_\Phi \\
&= L_e(x \rightarrow \Theta) + L_r(x \rightarrow \Theta)
\end{align*}

This equation express an intuitive idea: the radiance produced by the point $x$ in the direction $\Theta$ is the sum of the emitted radiance and the reflected radiance. 

The reflected radiance is computed by taking all the possible directions of the hemisphere around $x$ and integrate the incoming radiance along those directions scaled by a factor $f_r(x, \Theta \leftrightarrow \Phi) cos(N_x, \Phi)$. 

The cosine is used to attenuate the radiance that arrive by a "direction rasante". 

The $f_r$ function is called the \myem{bidirectional reflectance function} (BRDF) and express the exchange of radiance between the incoming direction $\Phi$ and the output direction $\Theta$. It has to respect three properties to be physically coherent:

\begin{itemize}
\item Helmotz reciprocity: $f_r(x, \Theta \leftrightarrow \Phi) = f_r(x, \Phi \leftrightarrow \Theta)$
\item Positivity: $f_r(x, \Theta \leftrightarrow \Phi) \geq 0$
\item Conservation of energy: $\int_{\Omega_x} f_r(x, \Theta \leftrightarrow \Phi) cos(N_x, \Phi) d\omega_\Phi \leq 1$
\end{itemize}

It's actually the rendering equation that a path tracer try to resolve. Let $O$ be the origin of the camera and $I$ the image we want to compute (a rectangle embedded in $\Rset^3$). Then the path tracing algorithm compute an approximation of the radiances $L(O \leftarrow \vec{OP})$, $\forall P \in I$.

\subsubsection{Solving the rendering equation}

The rendering equation is a recursive integral equation. The integrand of the equation contains the radiance function that we must compute:

\begin{align*}
L(x \rightarrow \Theta) &= L_e(x \rightarrow \Theta) + \int_{\Phi \in \Omega_x} f_r(x, \Theta \leftrightarrow \Phi) L(x \leftarrow \Phi) cos(N_x, \Phi) d\omega_\Phi \\
&= L_e(x \rightarrow \Theta) + \int_{\Phi \in \Omega_x} f_r(x, \Theta \leftrightarrow \Phi) L(r(x, \Phi) \rightarrow -\Phi) cos(N_x, \Phi) d\omega_\Phi
\end{align*}

In practive it is impossible to compute anatically the integral, it has to be estimated. The most commonly used method is the Monte-Carlo integration that provide the following estimator for the integral:

\begin{equation*}
\langle L_r(x \rightarrow \Theta) \rangle = \frac{1}{N} \sum_{i = 1}^{N} \frac{f_r(x, \Theta \leftrightarrow \Phi_i) L(r(x, \Phi_i) \rightarrow -\Phi_i) cos(N_x, \Phi_i)}{p(\Phi_i)}
\end{equation*}

$p$ is a probability density function (pdf) that is used to sample $N$ samples $(\Phi_i)_{i = 1...N}$ of the hemisphere $\Omega_x$.

This estimator is unbiased, it means that the esperance $E[\langle L_r(x \rightarrow \Theta) \rangle]$ is equal to $L_r(x \rightarrow \Theta)$. 

The variance of the estimator express its quality. The lower the variance is, the better is the estimator. We have:

\begin{equation*}
\sigma^2[\langle L_r(x \rightarrow \Theta) \rangle] = \frac{1}{N} \int_{\Omega_x} (\frac{f(\Phi)}{p(\Phi)} - L_r(x \rightarrow \Theta))^2 d\omega_\Phi
\end{equation*}

Then if we increase the number of samples we decrease the variance and the estimator gives better results. Another way to decrease the variance is to choose a good pdf. Actually the best is to choose a pdf that match the shape of the function to integrate (ie. give high density to samples that have high values for the function and low density to samples that have low values).

This str	ategy of choosing a good pdf is called \myem{importance sampling} and is over-used in global illumination to improve the convergence of the algorithms.

\subsubsection{The algorithm}

Donner l'algorithme en pseudo-code

\subsection{Skeleton based importance sampling}

Décrire la stratégie d'échantillonage basée sur le squelette

\subsection{Multiple importance sampling}

Décrire comment combiner les stratégies brdf + skeleton
