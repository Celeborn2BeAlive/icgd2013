

\section{Application to path tracing}

\subsection{The path tracing algorithm}

Path tracing is a global illumination algorithm that is able to render photo-realistic images of a scene viewed by a camera. The idea behind the algorithm is very simple: for each pixel of the image, throw rays of light through the pixel that will bounce on the scene to accumulate lighting exchanges. It is based on physical laws of radiometry.

\subsubsection{Basic definitions of radiometry}

Let $S$ be a set of surfaces of $\Rset^3$ that don't overlap ($\forall x \in \Rset^3$ there exists at most one surface of $S$ that contains $x$) and $S_L \subset S$ a set of surface lights. $S$ is called the scene.

The basic radiometric quantity is the \myem{radiance} $L(x \rightarrow \Theta)$ that express the quantity of light energy produce by the surface point $x \in \Rset^3$ towards direction $\Theta \in \Omega_x$ per unit of time per unit area per unit solid angle (expressed in $W.m^{-2}.sr^{-1}$).
This is the quantity that the eye actually "sees" and that must be computed. 

% image radiance

We can define another quantity related to radiance called \myem{incoming radiance} $L(x \leftarrow \Phi)$ that represents the radiance that reach $x$ from direction $\Phi$.

\begin{property}

The radiance remains constant along straight lines in the void.

\end{property}

That property allows us to write the incoming radiance in terms of radiance.

\begin{equation*}
L(x \leftarrow \Phi) = L(r(x, \Phi) \rightarrow -\Phi)
\end{equation*}

$r(x, \Phi)$ is the surface point seen by $x$ in the direction $\Phi$. It can be defined formally by:

\begin{align*}
r(x, \Phi) &= x + t_{min}\Phi \\
t_{min} &= min \lbrace t \in (0, +\infty]~ |~ x + t\Phi \in S \rbrace
\end{align*}

If $t_{min} = \infty$ then $r(x, \Phi)$ is undefined and $L(x \leftarrow \Phi) = 0$. We call $r$ the \myem{raytrace} function. In practice it is implemented by throwing a ray in the scene and looking for the first intersection.

A third quantity related to radiance is \myem{emitted radiance} $L_e(x \rightarrow \Theta)$. It is not null if $x$ is a point of a light source ($x \in S_L$). In practice the emitted radiance is given with the set $S_L$ as an input of the algorithm (in can be constant across each of the lights or given by a texture).

The radiance is the solution of an equation called the Rendering Equation:

\begin{align*}
L(x \rightarrow \Theta) &= L_e(x \rightarrow \Theta) + \int_{\Phi \in \Omega_x} f_r(x, \Theta \leftrightarrow \Phi) L(x \leftarrow \Phi) cos(N_x, \Phi) d\omega_\Phi \\
&= L_e(x \rightarrow \Theta) + L_r(x \rightarrow \Theta)
\end{align*}

This equation express an intuitive idea: the radiance produced by the point $x$ in the direction $\Theta$ is the sum of the emitted radiance and the reflected radiance. 

The reflected radiance is computed by taking all the possible directions of the hemisphere around $x$ and integrate the incoming radiance along those directions scaled by a factor $f_r(x, \Theta \leftrightarrow \Phi) cos(N_x, \Phi)$. 

The cosine is used to attenuate the radiance that arrive by a "direction rasante". $N_x$ is the surface's normal at point $x$.

The $f_r$ function is called the \myem{bidirectional reflectance function} (BRDF) and express the exchange of radiance between the incoming direction $\Phi$ and the output direction $\Theta$. Intuitively it represents the material properties of the surface at point $x$. A mirror doesn't reflect light the same manners a wall do, the BRDF encodes that. The BRDF has to respect three properties to be physically coherent:

\begin{itemize}
\item Helmotz reciprocity: $f_r(x, \Theta \leftrightarrow \Phi) = f_r(x, \Phi \leftrightarrow \Theta)$
\item Positivity: $f_r(x, \Theta \leftrightarrow \Phi) \geq 0$
\item Conservation of energy: $\int_{\Omega_x} f_r(x, \Theta \leftrightarrow \Phi) cos(N_x, \Phi) d\omega_\Phi \leq 1$
\end{itemize}

It's actually the rendering equation that a path tracer try to resolve. Let $O$ be the origin of the camera and $I$ the image we want to compute (a rectangle embedded in $\Rset^3$). Then the path tracing algorithm compute an approximation of the radiances $L(O \leftarrow \vec{OP})$, $\forall P \in I$.

\subsubsection{Solving the rendering equation}

The rendering equation is a recursive integral equation. The integrand of the equation contains the radiance function that we must compute:

\begin{align*}
L(x \rightarrow \Theta) &= L_e(x \rightarrow \Theta) + \int_{\Phi \in \Omega_x} f_r(x, \Theta \leftrightarrow \Phi) L(x \leftarrow \Phi) cos(N_x, \Phi) d\omega_\Phi \\
&= L_e(x \rightarrow \Theta) + \int_{\Phi \in \Omega_x} f_r(x, \Theta \leftrightarrow \Phi) L(r(x, \Phi) \rightarrow -\Phi) cos(N_x, \Phi) d\omega_\Phi
\end{align*}

In practive it is impossible to compute anatically the integral, it has to be estimated. The most commonly used method is the Monte-Carlo integration that provide the following estimator for the integral:

\begin{equation*}
\langle L_r(x \rightarrow \Theta) \rangle = \frac{1}{N} \sum_{i = 1}^{N} \frac{f_r(x, \Theta \leftrightarrow \Phi_i) L(r(x, \Phi_i) \rightarrow -\Phi_i) cos(N_x, \Phi_i)}{p(\Phi_i)}
\end{equation*}

$p$ is a probability density function (pdf) that is used to sample $N$ samples $(\Phi_i)_{i = 1...N}$ of the hemisphere $\Omega_x$.

This estimator is unbiased, it means that the esperance $E[\langle L_r(x \rightarrow \Theta) \rangle]$ is equal to $L_r(x \rightarrow \Theta)$. 

The variance of the estimator express its quality. The lower the variance is, the better is the estimator. We have:

\begin{equation*}
\sigma^2[\langle L_r(x \rightarrow \Theta) \rangle] = \frac{1}{N} \int_{\Omega_x} (\frac{f(\Phi)}{p(\Phi)} - L_r(x \rightarrow \Theta))^2 d\omega_\Phi
\end{equation*}

Then if we increase the number of samples we decrease the variance and the estimator gives better results. Another way to decrease the variance is to choose a good pdf. Actually the best is to choose a pdf that match the shape of the function to integrate (ie. give high density to samples that have high values for the function and low density to samples that have low values).

This str	ategy of choosing a good pdf is called \myem{importance sampling} and is over-used in global illumination to improve the convergence of the algorithms.

In the path tracing algorithm we cannot use more than one sample. Actually the evaluation of the integrand implies the evaluation of $L$ and thus a new application of the Monte-Carlo estimator. So if we use more than one sample the complexity of the algorithm becomes exponential (O($d^N$) with $d$ the length of a path and $N$ the number of samples).

\subsubsection{The algorithm}

We are now able to construct the algorithm for computing radiance:

\begin{algorithm}[h!]
\label{algo::incoming_radiance}
\caption[incoming_radiance]{Incoming radiance $L(x \leftarrow \Phi)$}
\KwData{An incoming direction $\Phi$, a point $x$} 
\KwResult{$L(x \leftarrow \Phi)$}
\Return $L(r(x, \Phi) \rightarrow -\Phi)$\;
\end{algorithm}

\begin{algorithm}[h!]
\label{algo::radiance}
\caption[radiance]{Radiance $L(x \rightarrow \Theta)$}
\KwData{An outcoming direction $\Theta$, a point $x$} 
\KwResult{$L(x \rightarrow \Theta)$}
$L \gets L_e(x \rightarrow \Theta)$\;
\If{continue the recursion} {
	$\Phi \gets sample(\Omega_x, p)$ \\
	$L \gets L + \frac{f_r(x, \Phi, \Theta) L(x \leftarrow \Phi) cos(N_x, \Phi)}{p(\Phi)}$\;
}
\Return L\;
\end{algorithm}

This algorithm is called for each pixel of the final image to compute. To improve the quality of the result we can throw multiple rays accross each pixel and computing the mean of the results.

In the radiance algorithm the $\Phi$ direction is sampled on $\Omega_x$ based on the pdf $p$. We will discuss what pdf we use in the next section.

The stopping condition of the recursion is not specified here. In our implementation we simply fix a maximum depth for the path but it's a bad solution. Actually it biased the method because some light paths have no chance to be evaluated. A better solution is to use a method called russian roulette.

\subsection{Skeleton based importance sampling}

We have presented the path tracing algorithm without describe the pdf $p$ used to sample the hemisphere around a point. The choice of the pdf is very important because the convergence speed of the algorithm depends on it. Here is the integrand of the integral estimated with Monte-Carlo:

\begin{equation*}
f_r(x, \Phi, \Theta) L(x \leftarrow \Phi) cos(N_x, \Phi)
\end{equation*}

To improve the quality we have to choose a pdf that match the shape of this function. There is a cosine factor in the function. It takes higher values when $\Phi$ is close to $N_x$. That means we have to give better chances to be samples to directions that are close to the normal. But it's not enough: when the environment is not totally diffuse, the brdf take higher values for some pair of directions. A perfect mirror, for exemple, reflect light only in a single direction: the symetric of $\Theta$ by the normal $N_x$. In that case it's totally useless to sample $\Omega_x$, we juste have to take the correct direction without taking into account the cosine.

The most common strategy used to sample $\Omega_x$ is to use the BRDF because we know it: it is given as an input of the algorithm for exemple with textures.

$L$ is rarelly used because we cannot evaluate it in constant time. Remember that it represents the distribution of light in the scene. It takes high values when $\Phi$ carry a lot of energy. Out method is based an a topological skeleton of the void (because light travels in the void) to sample $\Omega_x$ according to $L$.

\subsubsection{Computation of the skeleton}

The skeleton is computed in two steps:

\begin{itemize}
\item Voxelization of the void
\item Skeletonization in the cubical complex framework
\end{itemize}

The voxelization is done with a software called Binvox. It voxelizes the surfaces of the scene and we invert it to get the voxelization of the void. The voxelization is then converted to a cubical complex and we apply our algorithm to skeletonize it. We get a curvilinear skeleton that has the same topology than the void.

The skeleton is represented by a graph of 3D positions with edges encoding the topology.

\subsubsection{Construction of the importance points}

Given the skeleton we compute a set of points called importance points. This points will be used to sample $\Omega_x$ in the path tracing algorithm.

Let $L$ be a light of the scene ($L \in S_L$) and $n_L$ the shortest visible node by $L$. We first compute a tree of shortest paths along the skeleton with $n_L$ as root. For that we use the Dijkstra algorithm with a distance based on visibility from $n_L$: We put $d(n, m) = 1$ if $m$ is visible from $n_L$ and $d(n, m) = 10$ if not. It results that the paths that are enlighted by $L$ will have a shorter distance.

Let $n$ be a node of the skeleton and $V_n$ the set of visible nodes from $n$ along the shortest path toward $n_L$. The importance point $imp_n$ associated to $n$ is computed by taking the barycenter of $V_n$.

\subsubsection{Sampling according to $L$}

Given a point $x$ and a direction $\Theta$ we want to compute $L(x \rightarrow \Theta)$ and then sample the hemisphere $\Omega_x$. We search for the nearest skeleton node $n$ and its importance point $imp_n$. We sample the hemisphere with a power-cosine pdf center on $\vec{ximp_n}$:

\begin{equation*}
p_{skel}(\Phi) = \frac{s + 1}{2\pi} cos^s \alpha
\end{equation*}

with $\alpha$ the angle between $\vec{ximp_n}$ and $\Phi$ and $s$ a parameter called skeleton strength.  The more $s$ is high, the more we sample close $\vec{ximp_n}$.

\subsubsection{Results}

\subsubsection{Problems}

A few problems arise from this sampling strategy:

\begin{itemize}
\item $\vec{ximp_n}$ may point backward the surface (ie. $cos(\vec{ximp_n}, N_x) < 0$)
\item The importance point $imp_n$ may be not visible from $x$
\end{itemize}

In those case we don't use the skeleton and switch to a basic BRDF sampling.

Another problem from the method is the apparition of speckles. Speckles are anormally white pixels on the computed image that tend to vanish when we augment the number of rays thrown by pixel. It comes from the Monte-Carlo estimator when we sample a direction $\Phi$ with a low pdf $p(\Phi)$ but a high value $f_r(x, \Theta \leftrightarrow \Phi) L(x \leftarrow \Phi) cos(N_x, \Phi)$: the ratio becomes very high and speckles appears. In the next section we discuss a method to attenuate the speckles.

\subsection{Skeleton based multiple importance sampling}

Our strategy is good, especially in dark areas. It reduces noise by taking into account the distribution of energy in the scene. The problem is that we take into account only one importance direction for sampling, we totally ignore the BRDF and the cosine factor (unless we fall in a bad case like the two describe above). We implemented a solution called multiple importance sampling (MIS) that is able to combine multiple sampling strategies into one.

\subsubsection{Multiple importance sampling}

Let $f(x) = f_1(x)f_2(x)...f_n(x)$ a function that we want to integrate over a domain $D$:

\begin{equation*}
F = \int_{D} f_1(x)f_2(x)...f_n(x) dx
\end{equation*}

Monte-Carlo suggests us to use the estimator (with one sample $x$ in that case, like in path tracing):

\begin{equation*}
\langle F \rangle = \frac{f_1(x)f_2(x)...f_n(x)}{p(x)}
\end{equation*}

But how to choose efficiently $p$ ? Suppose we have $n$ sampling strategy $p_1, p_2, ..., p_n$, with $p_i$ efficient for the function $f_i$. Let $c_1, ..., c_n$ be $n$ scalar from $[0,1]$ such that $\sum_{i = 1}{n} c_i = 1$. $c_i$ is the probability to select the strategy $p_i$ for sampling. Then the combined pdf of a sample $x$ is:

\begin{equation*}
p(x) = \sum_{i = 1}^{n} c_i p_i(x)
\end{equation*}

We use this pdf for Monte-Carlo estimation. First we choose the strategy to use, based on the probabilities $(c_i)_{i = 1...n}$, then we sample with $p_i$ and then we estimate the integral by $\frac{f_1(x)f_2(x)...f_n(x)}{p(x)}$. This method is called multiple importance sampling.

\subsubsection{MIS for skeleton based path tracing}

In our case we have the following function to integrate:

\begin{equation*}
f_r(x, \Theta \leftrightarrow \Phi) L(x \leftarrow \Phi) cos(N_x, \Phi)
\end{equation*}

We suppose that we have a pdf $p_{brdf}$ that efficiently sample $\Omega_x$ according to the product $f_r(x, \Theta \leftrightarrow \Phi) cos(N_x, \Phi)$ and our strategy $p_{skel}$ that efficiently sample according to $L(x \leftarrow \Phi)$.

Let $c_{skel}$ be the probability to sample with the strategy $p_{skel}$ and $1 - c_{skel}$ the probability to sample with $p_{brdf}$ ($c_{skel}$ could be a parameter of the program). That gives us the following algorithm to sample:

\begin{algorithm}[h!]
\label{algo::MIS}
\caption[MIS]{Multiple importance sampling}
\KwData{An outcoming direction $\Theta$, a point $x$} 
\KwResult{A incoming direction $\Phi$ and its pdf $p(\Phi)$}
$r \gets$ a random number between 0 and 1\;
\If{$r \leq c_{skel}$} {
	\Return $\Phi \gets sample(\Omega_x, p_{skel})$
} \Else {
	\Return $\Phi \gets sample(\Omega_x, p_{brdf})$
}

\Return $\Phi, p(\Phi) \gets c_{skel} p_{skel}(\Phi) + (1 - c_{skel}) p_{brdf}(\Phi)$
\end{algorithm}

\subsubsection{Results}

